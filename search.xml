<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5分钟彻底理解Redis持久化</title>
    <url>/2019/10/28/5%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>在默认情况下，Redis将内存数据库快照保存到dump.rdb的二进制文件中。<br>可以对Redis进行设置，让它在“N秒内数据集至少有N个改动”， 这一条件被满足时，自动保存一次数据集。比如说：让Redis满足“60秒内至少有1000个键被改动”这一个条件时，自动保存一次数据集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure>

<p>除了在配置文件中使用save关键字设置RDB快照，还可以在命令行中手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件。<br>每次执行命令都会将所有redis内存快照保存到一个rdb文件里，并覆盖原有的rdb快照文件。<br>save是同步命令，bgsave是异步命令，bgsave会从redis主进程fork出一个子进程专门用来生成rdb二进制文件。</p>
<h2 id="AOF（append-only-file）"><a href="#AOF（append-only-file）" class="headerlink" title="AOF（append only file）"></a>AOF（append only file）</h2><p>快照功能并不是非常durable，如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入且未保存到快照中的那些数据。从1.1版本，redis增加了一种完全durable的方式：AOF持久化，将修改的每一条指令记录进appendonly.aof中。修改配置文件来打开aof功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>打开aof功能，每当redis执行一个改变数据集的命令时，这个命令就会追加到aof文件的末尾。这样的话，当redis重新启动时，程序就会通过执行aof文件中的命令来达到重建数据集的目的。<br>可以配置redis多久才将命令持久化到磁盘一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到aof文件时就执行一个持久化，非常慢但是安全</span><br><span class="line">appendfsync everysec：每秒执行一次持久化，足够快（和使用rdb持久化差不多）并且在故障时只会丢失1秒钟的数据</span><br><span class="line">appendfsync no：从不持久化，将数据交给操作系统来处理。redis处理命令速度加快但是不安全。</span><br></pre></td></tr></table></figure>
<p>默认情况下 ，每秒执行一次fsync， 这种fsync策略可以兼顾安全性和速度。<br>rdb和aof的区别：</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1027-01.jpg" alt=""></p>
<p>redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof文件一般来说数据更安全一点。</p>
<p>二、AOF重写<br>aof文件里可能有太多“琐碎”指令，所以aof会定期根据内存的最新数据重新生成aof文件<br>有两个配置可以控制aof自动重写的频率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb： aof文件至少要达到64m才会触发制动重写，文件太小恢复速度本来就很快，重写的意义不大</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100：aof文件上一次重写后文件大小增长了100%则再次触发重写</span><br></pre></td></tr></table></figure>
<p>当然aof还可以手动重写，进入redis客户端执行命令bgrewriteaof重写aof。<br>触发aof重写时，redis会fork一个子进程去做，不会对redis正常命令处理有太多影响。</p>
<h1 id="Redis-4-0混合持久化"><a href="#Redis-4-0混合持久化" class="headerlink" title="Redis 4.0混合持久化"></a>Redis 4.0混合持久化</h1><p>重启redis恢复数据集时，很少会使用rdb来恢复内存状态，因为会丢失大量数据。通常会使用aof日志恢复数据，但是重放aof日志性能相对rdb来说要慢很多，这样在redis实例很大的情况下，启动需要花费很长时间。Redis4.0为了解决这个问题，带来了新的持久化选项——混合持久化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>混合持久化aof文件结构：</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1027-02.jpg" alt=""></p>
<p>如果开启了混合持久化，aof在重写时，不再是单纯将内存数据转换为RESP命令写入aof文件，而是将重写这一刻之前的内存做rdb快照处理，并且将rdb快照内容和增量的aof修改内存数据的命令存在一起，都写入新的aof文件，新的aof文件一开始不叫appendonly.aof，等到重写完成后，新的aof文件才会进行改名，原子的覆盖原有的aof文件，完成新旧两个aof文件的替换。<br>于是在redis重启的时候，可以先加载rdb文件，然后再重放增量的aof日志就可以完全替代之前的aof全量文件重放，因此重启效率大幅得到提高。</p>
<blockquote>
<p>还没关注我的公众号？ </p>
</blockquote>
<ul>
<li>扫文末二维码关注公众号【小强的进阶之路】可领取如下:</li>
<li>学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程； </li>
<li>100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全； </li>
<li>软件工具：几乎包括你在编程道路上的可能会用到的大部分软件； </li>
<li>项目源码：20个JavaWeb项目源码。<br><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E5%B0%8F%E5%BC%BA%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.PNG" alt="小强的进阶之路二维码"></li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>在微博微信场景下学习Redis数据结构</title>
    <url>/2019/10/24/%E5%9C%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%AD%A6%E4%B9%A0Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载地址：http://redis.io/download</span><br><span class="line"></span><br><span class="line">安装步骤：</span><br><span class="line">1、yum install gcc</span><br><span class="line">2、wget http://download.redis.io/releases/redis‐5.0.3.tar.gz</span><br><span class="line">tar xzf redis‐5.0.3.tar.gz</span><br><span class="line">cd redis‐5.0.3</span><br><span class="line">3、make</span><br><span class="line">4、src/redis‐server redis.conf（注意要使用后台启动，所以修改redis.conf里的daemonize改为y</span><br><span class="line">es)</span><br><span class="line">5、ps ‐ef | grep redis</span><br><span class="line">6、src/redis‐cli</span><br></pre></td></tr></table></figure>

<h2 id="Redis核心数据结构以及使用场景"><a href="#Redis核心数据结构以及使用场景" class="headerlink" title="Redis核心数据结构以及使用场景"></a>Redis核心数据结构以及使用场景</h2><p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-1.jpg" alt=""></p>
<h3 id="String结构"><a href="#String结构" class="headerlink" title="String结构"></a>String结构</h3><ul>
<li><p>字符串常用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET  key  value 			//存入字符串键值对</span><br><span class="line">MSET  key  value [key value ...] 	//批量存储字符串键值对</span><br><span class="line">SETNX  key  value 		        //存入一个不存在的字符串键值对</span><br><span class="line">GET  key 			        //获取一个字符串键值</span><br><span class="line">MGET  key  [key ...]	 	//批量获取字符串键值</span><br><span class="line">DEL  key  [key ...] 		//删除一个键</span><br><span class="line">EXPIRE  key  seconds 		//设置一个键的过期时间(秒)</span><br></pre></td></tr></table></figure>
</li>
<li><p>原子加减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCR  key 			//将key中储存的数字值加1</span><br><span class="line">DECR  key 			//将key中储存的数字值减1</span><br><span class="line">INCRBY  key  increment 	//将key所储存的值加上increment</span><br><span class="line">DECRBY  key  decrement 	//将key所储存的值减去decrement</span><br></pre></td></tr></table></figure>
</li>
<li><p>String应用场景</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-2.jpg" alt=""></p>
<p>这个是微信公众号的文章阅读量数量的统计，可以通过redis的string数据结构来解决。使用incr原子操作命令，redis的key是article：readcount：{文章id}，当该文章被阅读时，调用incr命令，阅读数量加一，通过get该redis的key，实现文章阅读数量统计的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr article：readcount：&#123;文章id&#125;</span><br><span class="line">get article：readcount：&#123;文章id&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><ul>
<li>Hash常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET  key  field  value 			//存储一个哈希表key的键值</span><br><span class="line">HSETNX  key  field  value 		//存储一个不存在的哈希表key的键值</span><br><span class="line">HMSET  key  field  value [field value ...] 	//在一个哈希表key中存储多个键值对</span><br><span class="line">HGET  key  field 				//获取哈希表key对应的field键值</span><br><span class="line">HMGET  key  field  [field ...] 		//批量获取哈希表key中多个field键值</span><br><span class="line">HDEL  key  field  [field ...] 		//删除哈希表key中的field键值</span><br><span class="line">HLEN  key				//返回哈希表key中field的数量</span><br><span class="line">HGETALL  key				//返回哈希表key中所有的键值</span><br><span class="line">HINCRBY  key  field  increment 		//为哈希表key中field键的值加上增量increment</span><br></pre></td></tr></table></figure></li>
<li>Hash使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-3.jpg" alt=""></p>
<p>这个是京东购物车的截图，可以看到很多功能都用redis的命令可来实现。在redis中保存对商品id、购物车id等等id的操作，在前端保存对于该商品的描述，在操作购物车的时候，底层其实就是操作redis的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加商品：hset cart:1001 1088 1</span><br><span class="line">添加数量：hincrby cart:1001 1088 1</span><br><span class="line">商品总数：hlen cart:1001</span><br><span class="line">删除商品：hdel cart:1001 1008</span><br><span class="line">获取购物车所有商品： hgetall cart:1001</span><br></pre></td></tr></table></figure>
<ul>
<li>Hash优缺点<br>优点：同类数据归类整合存储，方便数据管理，相比string操作消耗内存与cpu更小<br>缺点：过期功能上不能使用在field上，只能使用在key上</li>
</ul>
<h3 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h3><ul>
<li><p>List常用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH  key  value [value ...] 		//将一个或多个值value插入到key列表的表头(最左边)</span><br><span class="line">RPUSH  key  value [value ...]	 	//将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">LPOP  key			//移除并返回key列表的头元素</span><br><span class="line">RPOP  key			//移除并返回key列表的尾元素</span><br><span class="line">LRANGE  key  start  stop		//返回列表key中指定区间内的元素，区间以偏移量start和stop指定</span><br><span class="line"></span><br><span class="line">BLPOP  key  [key ...]  timeout	//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待，timeout秒,如果timeout=0,一直阻塞等待</span><br><span class="line">BRPOP  key  [key ...]  timeout 	//从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待，timeout秒,如果timeout=0,一直阻塞等待</span><br></pre></td></tr></table></figure>
</li>
<li><p>List的应用场景</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-4.jpg" alt=""></p>
<p>这是我们经常使用的新浪微博，我们看在微博文章中如何使用redis的list数据结构。新浪微博是使用redis的大户，据在新浪工作的朋友说，新浪使用redis的总容量超过500T，可想而知几乎70%的功能都在redis中操作。</p>
<p>“小米手机”发微博，消息id为1001，使用的redis命令是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH msg：&#123;小强-id&#125; 1001</span><br></pre></td></tr></table></figure>
<p>“号外长沙”发微博，消息id为1002，使用的redis命令是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH msg：&#123;小强-id&#125; 1002</span><br></pre></td></tr></table></figure>
<p>小强查看最新10条的新浪微博消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRANGE msg：&#123;小强-id&#125; 0 10</span><br></pre></td></tr></table></figure>

<h3 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h3><ul>
<li>Set常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD  key  member  [member ...]			//往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SREM  key  member  [member ...]			//从集合key中删除元素</span><br><span class="line">SMEMBERS  key					//获取集合key中所有元素</span><br><span class="line">SCARD  key					//获取集合key的元素个数</span><br><span class="line">SISMEMBER  key  member			//判断member元素是否存在于集合key中</span><br><span class="line">SRANDMEMBER  key  [count]			//从集合key中选出count个元素，元素不从key中删除</span><br><span class="line">SPOP  key  [count]				//从集合key中选出count个元素，元素从key中删除</span><br></pre></td></tr></table></figure></li>
<li>Set运算操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SINTER  key  [key ...] 				//交集运算</span><br><span class="line">SINTERSTORE  destination  key  [key ..]		//将交集结果存入新集合destination中</span><br><span class="line">SUNION  key  [key ..] 				//并集运算</span><br><span class="line">SUNIONSTORE  destination  key  [key ...]		//将并集结果存入新集合destination中</span><br><span class="line">SDIFF  key  [key ...] 				//差集运算</span><br><span class="line">SDIFFSTORE  destination  key  [key ...]		//将差集结果存入新集合destination中</span><br></pre></td></tr></table></figure></li>
<li>Set使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-5.jpg" alt=""></p>
<p>使用这个抽奖界面作为set的使用场景的例子，相信大家对这个界面都很熟悉，微信小程序的“抽奖”功能，这个是使用redis的set数据结构的典型场景。<br>当用户点击“参与抽奖”，也就是把将用户ID加入集合中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD key &#123;userID&#125;</span><br></pre></td></tr></table></figure>
<p>查看参与抽奖的所有用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>
<p>抽取count名中奖用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure>

<h3 id="Zset有序集合结构"><a href="#Zset有序集合结构" class="headerlink" title="Zset有序集合结构"></a>Zset有序集合结构</h3><ul>
<li>ZSet常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD key score member [[score member]…]	//往有序集合key中加入带分值元素</span><br><span class="line">ZREM key member [member …]		//从有序集合key中删除元素</span><br><span class="line">ZSCORE key member 			//返回有序集合key中元素member的分值</span><br><span class="line">ZINCRBY key increment member		//为有序集合key中元素member的分值加上increment </span><br><span class="line">ZCARD key				//返回有序集合key中元素个数</span><br><span class="line">ZRANGE key start stop [WITHSCORES]	//正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]	//倒序获取有序集合key从start下标到stop下标的元素</span><br></pre></td></tr></table></figure></li>
<li>Zset使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-6.jpg" alt=""></p>
<p>微博热搜榜处处使用到了Redis的有序集合这个数据结构，我们都知道有序集合是对集合的一个扩展，增加了score字段。通过score字段，我们可以选出最大或者最小的topN，这样就有了排行榜，如果用传统的数据库去实现这个功能，估计对数据性能的消耗非常大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY  hotNews:20190819  1  乌镇十二时辰</span><br><span class="line">2）展示当日排行前十</span><br><span class="line">ZREVRANGE  hotNews:20190819  0  10  WITHSCORES </span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE  hotNews:20190813-20190819  7 </span><br><span class="line">hotNews:20190813  hotNews:20190814... hotNews:20190819</span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20190813-20190819  0  10  WITHSCORES</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还没关注我的公众号？ </p>
</blockquote>
<ul>
<li>扫文末二维码关注公众号【小强的进阶之路】可领取如下:</li>
<li>学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程； </li>
<li>100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全； </li>
<li>软件工具：几乎包括你在编程道路上的可能会用到的大部分软件； </li>
<li>项目源码：20个JavaWeb项目源码。<br><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E5%B0%8F%E5%BC%BA%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.PNG" alt="小强的进阶之路二维码"></li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Mysql索引底层数据结构与算法</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>索引是帮助MySQL高效获取数据的排好序的数据结构</p>
</blockquote>
<h2 id="索引数据结构对比"><a href="#索引数据结构对比" class="headerlink" title="索引数据结构对比"></a>索引数据结构对比</h2><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>  左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。<br> 如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E4%BA%8C%E5%8F%89%E6%A0%91%20%E7%B4%A2%E5%BC%95.jpg" alt="二叉树索引示意图"><br>如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>   本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；<br> 存储大数据量，树的高度不可控， 数量越大，树的高度越高；<br> 500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数；</p>
<h5 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h5><p> 通过散列可以快速获取磁盘文件指针，对于指定索引查找文件非常快，但是对于范围查找没法支持。</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>本质是多路二叉树；<br>叶节点具有相同的深度，叶节点的指针为空；<br>所有索引元素不重复；<br>节点中数据索引从左到右依次递增的；</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/B%E6%A0%91%E7%B4%A2%E5%BC%95.jpg" alt="B树索引示意图"></p>
<h5 id="B-树（B树的变种）"><a href="#B-树（B树的变种）" class="headerlink" title="B+树（B树的变种）"></a>B+树（B树的变种）</h5><p>非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；<br>叶子节点包含所有索引字段；<br>叶子节点比b树增加了指针连接；<br>叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/b+%E6%A0%91%E7%B4%A2%E5%BC%95.jpg" alt="B+树索引示意图"></p>
<h3 id="为什么mysql页文件默认16K？"><a href="#为什么mysql页文件默认16K？" class="headerlink" title="为什么mysql页文件默认16K？"></a>为什么mysql页文件默认16K？</h3><p>   MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)<br>那么一颗高度为2的B+树能存储的数据为：1170<em>16=18720条，一颗高度为3的B+树能存储的数据为：1170</em>1170*16=21902400（千万级条）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like `Innodb_page_size`</span><br></pre></td></tr></table></figure>
<p>因此，B+树存储大数据量的表也可以非常高效的获取数据，MySQL使用B+树作为索引的数据结构。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎最终作用于：表 ，不是数据库<br>在mysql的安装的根目录下，有一个data目录，里面存放的是所有表的数据。</p>
<ul>
<li>MyISAM：<br>MyISAM索引文件和数据文件是分离的（非聚集或稀疏）；<br>主键索引和辅助主键索引存储类似；</li>
</ul>
<p>frm文件：存储这张表的表结构<br>MYD文件：存储这张表的所有数据行<br>MYI文件：存储这张表的索引字段</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/MyIsam.jpg" alt="MyISAM存储引擎底层结构"></p>
<ul>
<li>InnoDB（聚集）：</li>
</ul>
<p>表数据文件本身是按照B+tree组织的一个索引结构文件<br>frm文件：存储这张表的表结构<br>ibd文件：存储这张表的所有数据行和索引字段<br>聚集(聚簇)索引—-叶节点包含完整数据记录</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/innodb.jpg" alt="InnoDB存储引擎底层结构"></p>
<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h3><ul>
<li>首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。</li>
<li>其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。</li>
<li>最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。</li>
</ul>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值？"><a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？"></a>为什么非主键索引结构叶子节点存储的是主键值？</h3><ul>
<li>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；</li>
<li>如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</li>
</ul>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><ul>
<li><p>联合索引的底层存储结构长什么样?</p>
<p>定义联合索引(员工级别，员工姓名，员工出生年月)，将联合索引按照索引顺序放入节点中，新插入节点时，先按照联合索引中的员工级别比较，如果相同会按照是员工姓名比较，如果员工级别和员工姓名都相同 最后是员工的出生年月比较。可以从图中从上到下，从左到右看，第一个B+树的节点 是通过联合索引的员工级别比较的，第二个节点是 员工级别相同，会按照员工姓名比较，第三个节点是  员工级别和员工姓名都相同，会按照员工出生年月比较。</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg" alt="联合索引示意图"></p>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
