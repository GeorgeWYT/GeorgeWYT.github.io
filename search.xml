<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring bean的生命周期</title>
    <url>/2019/11/04/Spring%20bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>学习spring源码主框架，从源码角度开发学习Spring bean的生命周期。<br>spring创建bean方法<br>org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String, java.lang.Class<T>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException &#123;</span><br><span class="line">		//doGetBean是获取bean的真实方法</span><br><span class="line">		return doGetBean(name, requiredType, null, false);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>真正执行spring创建bean方法doGetBean<br>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; T doGetBean(</span><br><span class="line">			final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">        //获取的beanname可能是重命名后的，这个获取原始的beanname，这里做别名解析</span><br><span class="line">		final String beanName = transformedBeanName(name);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		//先从spring缓存池中获取bean，这里是解决循环依赖的根本</span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		if (sharedInstance != null &amp;&amp; args == null) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				if (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot;   beanName  </span><br><span class="line">							&quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot;   beanName   &quot;&apos;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//如果从缓存中获取到bean，进行后续处理。</span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			//判断当前创建的bean是不是原型的，如果存在循环依赖，则抛异常</span><br><span class="line">			if (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				throw new BeanCurrentlyInCreationException(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			//获取父工厂</span><br><span class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">			//判断父工厂是否为空，以及当前容器中是否包含bean定义</span><br><span class="line">			if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				// Not found -&gt; check parent.</span><br><span class="line">				String nameToLookup = originalBeanName(name);</span><br><span class="line">				//根据构造函数是否有参数，来创建不同的bean</span><br><span class="line">				if (args != null) &#123;</span><br><span class="line">					// Delegation to parent with explicit args.</span><br><span class="line">					return (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					// No args -&gt; delegate to standard getBean method.</span><br><span class="line">					return parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">			if (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">			    //合并bean定义，存在抽象父bean定义，专门给子bean做继承的</span><br><span class="line">				final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				//检查bean定义的是否为抽象的，如果是则抛出异常</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">				//获取bean初始化的前置依赖beanname</span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				if (dependsOn != null) &#123;</span><br><span class="line">					for (String dep : dependsOn) &#123;</span><br><span class="line">						if (isDependent(beanName, dep)) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;Circular depends-on relationship between &apos;&quot;   beanName   &quot;&apos; and &apos;&quot;   dep   &quot;&apos;&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">						//解析以来的bean，并注册依赖的bean</span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						try &#123;</span><br><span class="line">					        //递归调用获取依赖bean</span><br><span class="line">							getBean(dep);</span><br><span class="line">						&#125;</span><br><span class="line">						catch (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">							throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									&quot;&apos;&quot;   beanName   &quot;&apos; depends on missing bean &apos;&quot;   dep   &quot;&apos;&quot;, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 创建bean的实例</span><br><span class="line">				if (mbd.isSingleton()) &#123;</span><br><span class="line">					sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object getObject() throws BeansException &#123;</span><br><span class="line">							try &#123;</span><br><span class="line">							    //构建bean的实例</span><br><span class="line">								return createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							catch (BeansException ex) &#123;</span><br><span class="line">								// Explicitly remove instance from singleton cache: It might have been put there</span><br><span class="line">								// eagerly by the creation process, to allow for circular reference resolution.</span><br><span class="line">								// Also remove any beans that received a temporary reference to the bean.</span><br><span class="line">								destroySingleton(beanName);</span><br><span class="line">								throw ex;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					//如果获取的bean是factroybean，那么要处理工厂bean。</span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else if (mbd.isPrototype()) &#123;</span><br><span class="line">					//创建原型bean</span><br><span class="line">					Object prototypeInstance = null;</span><br><span class="line">					try &#123;</span><br><span class="line">					    //在原型bena创建之前回调底层spring函数，开放性方法</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					finally &#123;</span><br><span class="line">					    //开放性方法</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					//如果获取的bean是factroybean，那么要处理工厂bean。</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					final Scope scope = this.scopes.get(scopeName);</span><br><span class="line">					if (scope == null) &#123;</span><br><span class="line">						throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot;   scopeName   &quot;&apos;&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					try &#123;</span><br><span class="line">					    //根据bean定义的scope来创建bean</span><br><span class="line">						Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">							@Override</span><br><span class="line">							public Object getObject() throws BeansException &#123;</span><br><span class="line">								beforePrototypeCreation(beanName);</span><br><span class="line">								try &#123;</span><br><span class="line">									return createBean(beanName, mbd, args);</span><br><span class="line">								&#125;</span><br><span class="line">								finally &#123;</span><br><span class="line">									afterPrototypeCreation(beanName);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (IllegalStateException ex) &#123;</span><br><span class="line">						throw new BeanCreationException(beanName,</span><br><span class="line">								&quot;Scope &apos;&quot;   scopeName   &quot;&apos; is not active for the current thread; consider &quot;  </span><br><span class="line">								&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 判断获取的类型是否匹配实际的bean实例</span><br><span class="line">		if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (TypeMismatchException ex) &#123;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Failed to convert bean &apos;&quot;   name   &quot;&apos; to required type &apos;&quot;  </span><br><span class="line">							ClassUtils.getQualifiedName(requiredType)   &quot;&apos;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)<br>这个方法是解决spring循环依赖问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">        //从一级缓存中获取实例bean，如果有直接返回对象</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		//singletonObject为空并且 beanname是否正在创建中的标识</span><br><span class="line">		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		    //防止并发获取bean</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">			    //从earlySingletonObjects早期缓冲池中获取bean</span><br><span class="line">				singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				    //从singletonFactories中获取bean的objectfactory</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">					    //调用objectfactory的getObject方法获取singletonObject</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						//同时放到earlySingletonObjects提前暴露出来</span><br><span class="line">						this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						//并从singletonFactories移除</span><br><span class="line">						this.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>获取实例bean<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">		Assert.notNull(beanName, &quot;&apos;beanName&apos; must not be null&quot;);</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">			if (singletonObject == null) &#123;</span><br><span class="line">				if (this.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					throw new BeanCreationNotAllowedException(beanName,</span><br><span class="line">							&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;  </span><br><span class="line">							&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(&quot;Creating shared instance of singleton bean &apos;&quot;   beanName   &quot;&apos;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//标识当前正在创建的对象，放到singletonsCurrentlyInCreation缓存中</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				boolean newSingleton = false;</span><br><span class="line">				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);</span><br><span class="line">				if (recordSuppressedExceptions) &#123;</span><br><span class="line">					this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">				    //调用接口objectfacotry的getObject方法， 这个方法被重写</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = true;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (IllegalStateException ex) &#123;</span><br><span class="line">					// Has the singleton object implicitly appeared in the meantime -&gt;</span><br><span class="line">					// if yes, proceed with it since the exception indicates that state.</span><br><span class="line">					singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">					if (singletonObject == null) &#123;</span><br><span class="line">						throw ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				catch (BeanCreationException ex) &#123;</span><br><span class="line">					if (recordSuppressedExceptions) &#123;</span><br><span class="line">						for (Exception suppressedException : this.suppressedExceptions) &#123;</span><br><span class="line">							ex.addRelatedCause(suppressedException);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					throw ex;</span><br><span class="line">				&#125;</span><br><span class="line">				finally &#123;</span><br><span class="line">					if (recordSuppressedExceptions) &#123;</span><br><span class="line">						this.suppressedExceptions = null;</span><br><span class="line">					&#125;</span><br><span class="line">					//当前bean已经创建好了，到singletonsCurrentlyInCreation中bean移除掉</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				if (newSingleton) &#123;</span><br><span class="line">				    //把创建好的bean加载到缓存池中，并移除二三级缓存</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//对bean判空</span><br><span class="line">			return (singletonObject != NULL_OBJECT ? singletonObject : null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>创建bean实例<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[])</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating instance of bean &apos;&quot;   beanName   &quot;&apos;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">		// Make sure bean class is actually resolved at this point, and</span><br><span class="line">		// clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">		// which cannot be stored in the shared merged bean definition.</span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123;</span><br><span class="line">			mbdToUse = new RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Prepare method overrides.</span><br><span class="line">		try &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 这里给后置处理器一个机会去创建代理对象，第一次创建bean到这里还没有创建好bean， 仅仅把切面信息解析出来放入缓存中</span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			if (bean != null) &#123;</span><br><span class="line">				return bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        //真正执行创建bean实例的方法doCreateBean</span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Finished creating instance of bean &apos;&quot;   beanName   &quot;&apos;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return beanInstance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>真正执行创建bean实例的方法doCreateBean<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		// Instantiate the bean.</span><br><span class="line">		BeanWrapper instanceWrapper = null;</span><br><span class="line">		if (mbd.isSingleton()) &#123;</span><br><span class="line">			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		if (instanceWrapper == null) &#123;</span><br><span class="line">		    //根据@bean， @autowire来创建有参构造函数， 或者无参数构造函数</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line">		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">		Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">        </span><br><span class="line">        //允许后置处理器去修改merge后的bean定义</span><br><span class="line">		synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">			if (!mbd.postProcessed) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				catch (Throwable ex) &#123;</span><br><span class="line">					throw new BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">							&quot;Post-processing of merged bean definition failed&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				mbd.postProcessed = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 判断earlySingletonObjects是否提前暴露bean对象</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Eagerly caching bean &apos;&quot;   beanName  </span><br><span class="line">						&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			//将已经创建好但是属性还没有赋值的bean对象，通过objectfacotry的形式来加载到缓存中用来解决循环依赖的问题</span><br><span class="line">			addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object getObject() throws BeansException &#123;</span><br><span class="line">					return getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Initialize the bean instance.</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		try &#123;</span><br><span class="line">		    //为刚刚创建的bean对象进行赋值</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			if (exposedObject != null) &#123;</span><br><span class="line">			    //初始化bean，并且通过开放性方法为bean赋值</span><br><span class="line">				exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">				throw (BeanCreationException) ex;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				throw new BeanCreationException(</span><br><span class="line">						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			Object earlySingletonReference = getSingleton(beanName, false);</span><br><span class="line">			if (earlySingletonReference != null) &#123;</span><br><span class="line">				if (exposedObject == bean) &#123;</span><br><span class="line">					exposedObject = earlySingletonReference;</span><br><span class="line">				&#125;</span><br><span class="line">				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">					String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">					for (String dependentBean : dependentBeans) &#123;</span><br><span class="line">						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">							actualDependentBeans.add(dependentBean);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					if (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">						throw new BeanCurrentlyInCreationException(beanName,</span><br><span class="line">								&quot;Bean with name &apos;&quot;   beanName   &quot;&apos; has been injected into other beans [&quot;  </span><br><span class="line">								StringUtils.collectionToCommaDelimitedString(actualDependentBeans)  </span><br><span class="line">								&quot;] in its raw version as part of a circular reference, but has eventually been &quot;  </span><br><span class="line">								&quot;wrapped. This means that said other beans do not use the final version of the &quot;  </span><br><span class="line">								&quot;bean. This is often the result of over-eager type matching - consider using &quot;  </span><br><span class="line">								&quot;&apos;getBeanNamesOfType&apos; with the &apos;allowEagerInit&apos; flag turned off, for example.&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    //注册自定义销毁bean的方法</span><br><span class="line">			registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>初始化已经创建好的bean实例<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">        //权限校验是否判断是否可以回调底层组件方法</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object run() &#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		  //实现自定义的bean的后置处理器的前置方法</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">		    //调用自定义的init方法或InitializingBean</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">		    //实现自定义的bean的后置处理器的后置方法</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是spring ioc模块bean生命周期的源代码解析。</p>
<blockquote>
<p>还没关注我的公众号？ </p>
</blockquote>
<ul>
<li>扫文末二维码关注公众号【小强的进阶之路】可领取如下:</li>
<li>学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程； </li>
<li>100多本书：包含C/C  、Java、Python三门编程语言的经典必看图书、LeetCode题解大全； </li>
<li>软件工具：几乎包括你在编程道路上的可能会用到的大部分软件； </li>
<li>项目源码：20个JavaWeb项目源码。<br><img src="https://img-blog.csdnimg.cn/20191102195622630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zMTM1MTQwOQ==,size_16,color_FFFFFF,t_70" alt="小强的进阶之路二维码"></li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟彻底理解Redis持久化</title>
    <url>/2019/10/28/5%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>在默认情况下，Redis将内存数据库快照保存到dump.rdb的二进制文件中。<br>可以对Redis进行设置，让它在“N秒内数据集至少有N个改动”， 这一条件被满足时，自动保存一次数据集。比如说：让Redis满足“60秒内至少有1000个键被改动”这一个条件时，自动保存一次数据集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure>

<p>除了在配置文件中使用save关键字设置RDB快照，还可以在命令行中手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件。<br>每次执行命令都会将所有redis内存快照保存到一个rdb文件里，并覆盖原有的rdb快照文件。<br>save是同步命令，bgsave是异步命令，bgsave会从redis主进程fork出一个子进程专门用来生成rdb二进制文件。</p>
<h2 id="AOF（append-only-file）"><a href="#AOF（append-only-file）" class="headerlink" title="AOF（append only file）"></a>AOF（append only file）</h2><p>快照功能并不是非常durable，如果redis因为某些原因而造成故障停机，那么服务器将丢失最近写入且未保存到快照中的那些数据。从1.1版本，redis增加了一种完全durable的方式：AOF持久化，将修改的每一条指令记录进appendonly.aof中。修改配置文件来打开aof功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>打开aof功能，每当redis执行一个改变数据集的命令时，这个命令就会追加到aof文件的末尾。这样的话，当redis重新启动时，程序就会通过执行aof文件中的命令来达到重建数据集的目的。<br>可以配置redis多久才将命令持久化到磁盘一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always：每次有新命令追加到aof文件时就执行一个持久化，非常慢但是安全</span><br><span class="line">appendfsync everysec：每秒执行一次持久化，足够快（和使用rdb持久化差不多）并且在故障时只会丢失1秒钟的数据</span><br><span class="line">appendfsync no：从不持久化，将数据交给操作系统来处理。redis处理命令速度加快但是不安全。</span><br></pre></td></tr></table></figure>
<p>默认情况下 ，每秒执行一次fsync， 这种fsync策略可以兼顾安全性和速度。<br>rdb和aof的区别：</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1027-01.jpg" alt=""></p>
<p>redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof文件一般来说数据更安全一点。</p>
<p>二、AOF重写<br>aof文件里可能有太多“琐碎”指令，所以aof会定期根据内存的最新数据重新生成aof文件<br>有两个配置可以控制aof自动重写的频率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb： aof文件至少要达到64m才会触发制动重写，文件太小恢复速度本来就很快，重写的意义不大</span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100：aof文件上一次重写后文件大小增长了100%则再次触发重写</span><br></pre></td></tr></table></figure>
<p>当然aof还可以手动重写，进入redis客户端执行命令bgrewriteaof重写aof。<br>触发aof重写时，redis会fork一个子进程去做，不会对redis正常命令处理有太多影响。</p>
<h1 id="Redis-4-0混合持久化"><a href="#Redis-4-0混合持久化" class="headerlink" title="Redis 4.0混合持久化"></a>Redis 4.0混合持久化</h1><p>重启redis恢复数据集时，很少会使用rdb来恢复内存状态，因为会丢失大量数据。通常会使用aof日志恢复数据，但是重放aof日志性能相对rdb来说要慢很多，这样在redis实例很大的情况下，启动需要花费很长时间。Redis4.0为了解决这个问题，带来了新的持久化选项——混合持久化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>混合持久化aof文件结构：</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1027-02.jpg" alt=""></p>
<p>如果开启了混合持久化，aof在重写时，不再是单纯将内存数据转换为RESP命令写入aof文件，而是将重写这一刻之前的内存做rdb快照处理，并且将rdb快照内容和增量的aof修改内存数据的命令存在一起，都写入新的aof文件，新的aof文件一开始不叫appendonly.aof，等到重写完成后，新的aof文件才会进行改名，原子的覆盖原有的aof文件，完成新旧两个aof文件的替换。<br>于是在redis重启的时候，可以先加载rdb文件，然后再重放增量的aof日志就可以完全替代之前的aof全量文件重放，因此重启效率大幅得到提高。</p>
<blockquote>
<p>还没关注我的公众号？ </p>
</blockquote>
<ul>
<li>扫文末二维码关注公众号【小强的进阶之路】可领取如下:</li>
<li>学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程； </li>
<li>100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全； </li>
<li>软件工具：几乎包括你在编程道路上的可能会用到的大部分软件； </li>
<li>项目源码：20个JavaWeb项目源码。<br><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E5%B0%8F%E5%BC%BA%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.PNG" alt="小强的进阶之路二维码"></li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>在微博微信场景下学习Redis数据结构</title>
    <url>/2019/10/24/%E5%9C%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%AD%A6%E4%B9%A0Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载地址：http://redis.io/download</span><br><span class="line"></span><br><span class="line">安装步骤：</span><br><span class="line">1、yum install gcc</span><br><span class="line">2、wget http://download.redis.io/releases/redis‐5.0.3.tar.gz</span><br><span class="line">tar xzf redis‐5.0.3.tar.gz</span><br><span class="line">cd redis‐5.0.3</span><br><span class="line">3、make</span><br><span class="line">4、src/redis‐server redis.conf（注意要使用后台启动，所以修改redis.conf里的daemonize改为y</span><br><span class="line">es)</span><br><span class="line">5、ps ‐ef | grep redis</span><br><span class="line">6、src/redis‐cli</span><br></pre></td></tr></table></figure>

<h2 id="Redis核心数据结构以及使用场景"><a href="#Redis核心数据结构以及使用场景" class="headerlink" title="Redis核心数据结构以及使用场景"></a>Redis核心数据结构以及使用场景</h2><p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-1.jpg" alt=""></p>
<h3 id="String结构"><a href="#String结构" class="headerlink" title="String结构"></a>String结构</h3><ul>
<li><p>字符串常用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET  key  value 			//存入字符串键值对</span><br><span class="line">MSET  key  value [key value ...] 	//批量存储字符串键值对</span><br><span class="line">SETNX  key  value 		        //存入一个不存在的字符串键值对</span><br><span class="line">GET  key 			        //获取一个字符串键值</span><br><span class="line">MGET  key  [key ...]	 	//批量获取字符串键值</span><br><span class="line">DEL  key  [key ...] 		//删除一个键</span><br><span class="line">EXPIRE  key  seconds 		//设置一个键的过期时间(秒)</span><br></pre></td></tr></table></figure>
</li>
<li><p>原子加减</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCR  key 			//将key中储存的数字值加1</span><br><span class="line">DECR  key 			//将key中储存的数字值减1</span><br><span class="line">INCRBY  key  increment 	//将key所储存的值加上increment</span><br><span class="line">DECRBY  key  decrement 	//将key所储存的值减去decrement</span><br></pre></td></tr></table></figure>
</li>
<li><p>String应用场景</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-2.jpg" alt=""></p>
<p>这个是微信公众号的文章阅读量数量的统计，可以通过redis的string数据结构来解决。使用incr原子操作命令，redis的key是article：readcount：{文章id}，当该文章被阅读时，调用incr命令，阅读数量加一，通过get该redis的key，实现文章阅读数量统计的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr article：readcount：&#123;文章id&#125;</span><br><span class="line">get article：readcount：&#123;文章id&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash结构"><a href="#Hash结构" class="headerlink" title="Hash结构"></a>Hash结构</h3><ul>
<li>Hash常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HSET  key  field  value 			//存储一个哈希表key的键值</span><br><span class="line">HSETNX  key  field  value 		//存储一个不存在的哈希表key的键值</span><br><span class="line">HMSET  key  field  value [field value ...] 	//在一个哈希表key中存储多个键值对</span><br><span class="line">HGET  key  field 				//获取哈希表key对应的field键值</span><br><span class="line">HMGET  key  field  [field ...] 		//批量获取哈希表key中多个field键值</span><br><span class="line">HDEL  key  field  [field ...] 		//删除哈希表key中的field键值</span><br><span class="line">HLEN  key				//返回哈希表key中field的数量</span><br><span class="line">HGETALL  key				//返回哈希表key中所有的键值</span><br><span class="line">HINCRBY  key  field  increment 		//为哈希表key中field键的值加上增量increment</span><br></pre></td></tr></table></figure></li>
<li>Hash使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-3.jpg" alt=""></p>
<p>这个是京东购物车的截图，可以看到很多功能都用redis的命令可来实现。在redis中保存对商品id、购物车id等等id的操作，在前端保存对于该商品的描述，在操作购物车的时候，底层其实就是操作redis的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加商品：hset cart:1001 1088 1</span><br><span class="line">添加数量：hincrby cart:1001 1088 1</span><br><span class="line">商品总数：hlen cart:1001</span><br><span class="line">删除商品：hdel cart:1001 1008</span><br><span class="line">获取购物车所有商品： hgetall cart:1001</span><br></pre></td></tr></table></figure>
<ul>
<li>Hash优缺点<br>优点：同类数据归类整合存储，方便数据管理，相比string操作消耗内存与cpu更小<br>缺点：过期功能上不能使用在field上，只能使用在key上</li>
</ul>
<h3 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h3><ul>
<li><p>List常用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH  key  value [value ...] 		//将一个或多个值value插入到key列表的表头(最左边)</span><br><span class="line">RPUSH  key  value [value ...]	 	//将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">LPOP  key			//移除并返回key列表的头元素</span><br><span class="line">RPOP  key			//移除并返回key列表的尾元素</span><br><span class="line">LRANGE  key  start  stop		//返回列表key中指定区间内的元素，区间以偏移量start和stop指定</span><br><span class="line"></span><br><span class="line">BLPOP  key  [key ...]  timeout	//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待，timeout秒,如果timeout=0,一直阻塞等待</span><br><span class="line">BRPOP  key  [key ...]  timeout 	//从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待，timeout秒,如果timeout=0,一直阻塞等待</span><br></pre></td></tr></table></figure>
</li>
<li><p>List的应用场景</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-4.jpg" alt=""></p>
<p>这是我们经常使用的新浪微博，我们看在微博文章中如何使用redis的list数据结构。新浪微博是使用redis的大户，据在新浪工作的朋友说，新浪使用redis的总容量超过500T，可想而知几乎70%的功能都在redis中操作。</p>
<p>“小米手机”发微博，消息id为1001，使用的redis命令是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH msg：&#123;小强-id&#125; 1001</span><br></pre></td></tr></table></figure>
<p>“号外长沙”发微博，消息id为1002，使用的redis命令是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LPUSH msg：&#123;小强-id&#125; 1002</span><br></pre></td></tr></table></figure>
<p>小强查看最新10条的新浪微博消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRANGE msg：&#123;小强-id&#125; 0 10</span><br></pre></td></tr></table></figure>

<h3 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h3><ul>
<li>Set常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD  key  member  [member ...]			//往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SREM  key  member  [member ...]			//从集合key中删除元素</span><br><span class="line">SMEMBERS  key					//获取集合key中所有元素</span><br><span class="line">SCARD  key					//获取集合key的元素个数</span><br><span class="line">SISMEMBER  key  member			//判断member元素是否存在于集合key中</span><br><span class="line">SRANDMEMBER  key  [count]			//从集合key中选出count个元素，元素不从key中删除</span><br><span class="line">SPOP  key  [count]				//从集合key中选出count个元素，元素从key中删除</span><br></pre></td></tr></table></figure></li>
<li>Set运算操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SINTER  key  [key ...] 				//交集运算</span><br><span class="line">SINTERSTORE  destination  key  [key ..]		//将交集结果存入新集合destination中</span><br><span class="line">SUNION  key  [key ..] 				//并集运算</span><br><span class="line">SUNIONSTORE  destination  key  [key ...]		//将并集结果存入新集合destination中</span><br><span class="line">SDIFF  key  [key ...] 				//差集运算</span><br><span class="line">SDIFFSTORE  destination  key  [key ...]		//将差集结果存入新集合destination中</span><br></pre></td></tr></table></figure></li>
<li>Set使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-5.jpg" alt=""></p>
<p>使用这个抽奖界面作为set的使用场景的例子，相信大家对这个界面都很熟悉，微信小程序的“抽奖”功能，这个是使用redis的set数据结构的典型场景。<br>当用户点击“参与抽奖”，也就是把将用户ID加入集合中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD key &#123;userID&#125;</span><br></pre></td></tr></table></figure>
<p>查看参与抽奖的所有用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>
<p>抽取count名中奖用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure>

<h3 id="Zset有序集合结构"><a href="#Zset有序集合结构" class="headerlink" title="Zset有序集合结构"></a>Zset有序集合结构</h3><ul>
<li>ZSet常用操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD key score member [[score member]…]	//往有序集合key中加入带分值元素</span><br><span class="line">ZREM key member [member …]		//从有序集合key中删除元素</span><br><span class="line">ZSCORE key member 			//返回有序集合key中元素member的分值</span><br><span class="line">ZINCRBY key increment member		//为有序集合key中元素member的分值加上increment </span><br><span class="line">ZCARD key				//返回有序集合key中元素个数</span><br><span class="line">ZRANGE key start stop [WITHSCORES]	//正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]	//倒序获取有序集合key从start下标到stop下标的元素</span><br></pre></td></tr></table></figure></li>
<li>Zset使用场景</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/201910/1020-6.jpg" alt=""></p>
<p>微博热搜榜处处使用到了Redis的有序集合这个数据结构，我们都知道有序集合是对集合的一个扩展，增加了score字段。通过score字段，我们可以选出最大或者最小的topN，这样就有了排行榜，如果用传统的数据库去实现这个功能，估计对数据性能的消耗非常大。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）点击新闻</span><br><span class="line">ZINCRBY  hotNews:20190819  1  乌镇十二时辰</span><br><span class="line">2）展示当日排行前十</span><br><span class="line">ZREVRANGE  hotNews:20190819  0  10  WITHSCORES </span><br><span class="line">3）七日搜索榜单计算</span><br><span class="line">ZUNIONSTORE  hotNews:20190813-20190819  7 </span><br><span class="line">hotNews:20190813  hotNews:20190814... hotNews:20190819</span><br><span class="line">4）展示七日排行前十</span><br><span class="line">ZREVRANGE hotNews:20190813-20190819  0  10  WITHSCORES</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还没关注我的公众号？ </p>
</blockquote>
<ul>
<li>扫文末二维码关注公众号【小强的进阶之路】可领取如下:</li>
<li>学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程； </li>
<li>100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全； </li>
<li>软件工具：几乎包括你在编程道路上的可能会用到的大部分软件； </li>
<li>项目源码：20个JavaWeb项目源码。<br><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E5%B0%8F%E5%BC%BA%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF%E4%BA%8C%E7%BB%B4%E7%A0%81.PNG" alt="小强的进阶之路二维码"></li>
</ul>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Mysql索引底层数据结构与算法</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>索引是帮助MySQL高效获取数据的排好序的数据结构</p>
</blockquote>
<h2 id="索引数据结构对比"><a href="#索引数据结构对比" class="headerlink" title="索引数据结构对比"></a>索引数据结构对比</h2><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>  左边子节点的数据小于父节点数据，右边子节点的数据大于父节点数据。<br> 如果col2是索引，查找索引为89的行元素，那么只需要查找两次，就可以获取到行元素所在的磁盘指针地址。</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E4%BA%8C%E5%8F%89%E6%A0%91%20%E7%B4%A2%E5%BC%95.jpg" alt="二叉树索引示意图"><br>如果col1是索引，查找索引为6的行元素，那么需要查找六次，就可以获取到行元素所在的磁盘指针地址，即得到了该索引为6的行元素。因此二叉树不适合存储单边增长的序列字段，近乎全表扫描获取数据。</p>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p>   本质二叉树，属于二叉平衡树，jdk1.8 hashmap的底层实现；<br> 存储大数据量，树的高度不可控， 数量越大，树的高度越高；<br> 500w行数据，2的n次方=500w数据量， n是树的高度，也就是查询次数；</p>
<h5 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h5><p> 通过散列可以快速获取磁盘文件指针，对于指定索引查找文件非常快，但是对于范围查找没法支持。</p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><p>本质是多路二叉树；<br>叶节点具有相同的深度，叶节点的指针为空；<br>所有索引元素不重复；<br>节点中数据索引从左到右依次递增的；</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/B%E6%A0%91%E7%B4%A2%E5%BC%95.jpg" alt="B树索引示意图"></p>
<h5 id="B-树（B树的变种）"><a href="#B-树（B树的变种）" class="headerlink" title="B+树（B树的变种）"></a>B+树（B树的变种）</h5><p>非叶子节点不存储数据，只存储索引(冗余)和指针，可以放更多的索引，树高降低 ；<br>叶子节点包含所有索引字段；<br>叶子节点比b树增加了指针连接；<br>叶子节点有双向指针链接(首尾子节点还通过指针连接)，提高区间访问的性能，范围查找；</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/b+%E6%A0%91%E7%B4%A2%E5%BC%95.jpg" alt="B+树索引示意图"></p>
<h3 id="为什么mysql页文件默认16K？"><a href="#为什么mysql页文件默认16K？" class="headerlink" title="为什么mysql页文件默认16K？"></a>为什么mysql页文件默认16K？</h3><p>   MySQL每个B+树节点最大存储容量：16KB （指针+数据+索引）。假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)<br>那么一颗高度为2的B+树能存储的数据为：1170<em>16=18720条，一颗高度为3的B+树能存储的数据为：1170</em>1170*16=21902400（千万级条）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like `Innodb_page_size`</span><br></pre></td></tr></table></figure>
<p>因此，B+树存储大数据量的表也可以非常高效的获取数据，MySQL使用B+树作为索引的数据结构。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎最终作用于：表 ，不是数据库<br>在mysql的安装的根目录下，有一个data目录，里面存放的是所有表的数据。</p>
<ul>
<li>MyISAM：<br>MyISAM索引文件和数据文件是分离的（非聚集或稀疏）；<br>主键索引和辅助主键索引存储类似；</li>
</ul>
<p>frm文件：存储这张表的表结构<br>MYD文件：存储这张表的所有数据行<br>MYI文件：存储这张表的索引字段</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/MyIsam.jpg" alt="MyISAM存储引擎底层结构"></p>
<ul>
<li>InnoDB（聚集）：</li>
</ul>
<p>表数据文件本身是按照B+tree组织的一个索引结构文件<br>frm文件：存储这张表的表结构<br>ibd文件：存储这张表的所有数据行和索引字段<br>聚集(聚簇)索引—-叶节点包含完整数据记录</p>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/innodb.jpg" alt="InnoDB存储引擎底层结构"></p>
<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h3><ul>
<li>首先，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率，因此InnoDB必须要有主键。如果不手动指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。</li>
<li>其次，索引的数据类型是整型，一方面整型占有的磁盘空间或内存空间相比字符串更少，另一方面整型比较比字符串比较更快速，字符串比较是先转换为ASCII码，然后再比较的。</li>
<li>最后，B+树本质是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。</li>
</ul>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值？"><a href="#为什么非主键索引结构叶子节点存储的是主键值？" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？"></a>为什么非主键索引结构叶子节点存储的是主键值？</h3><ul>
<li>主键索引和非主键索引维护各自的B+树结构，当插入的数据的时候，由于数据只有一份，通过非主键索引获取到主键值，然后再去主键索引的B+树数据结构中找到对应的行数据，节省了内存空间；</li>
<li>如果非主键索引的叶子节点也存储一份数据，如果通过非主键索引插入数据，那么要向主键索引对应的行数据进行同步，那么会带来数据一致性问题。可以通过事务的方式解决，我们都知道使用事务后，就会对性能有所消耗。</li>
</ul>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><ul>
<li><p>联合索引的底层存储结构长什么样?</p>
<p>定义联合索引(员工级别，员工姓名，员工出生年月)，将联合索引按照索引顺序放入节点中，新插入节点时，先按照联合索引中的员工级别比较，如果相同会按照是员工姓名比较，如果员工级别和员工姓名都相同 最后是员工的出生年月比较。可以从图中从上到下，从左到右看，第一个B+树的节点 是通过联合索引的员工级别比较的，第二个节点是 员工级别相同，会按照员工姓名比较，第三个节点是  员工级别和员工姓名都相同，会按照员工出生年月比较。</p>
</li>
</ul>
<p><img src="http://blog-image-xiaoqiang.test.upcdn.net/blog/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.jpg" alt="联合索引示意图"></p>
]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
